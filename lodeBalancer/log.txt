1.密码加密
2.缓存memcached
3.一致性哈希
4.时间戳--》为什么功能而实现
5.长连接短连接
6.磁盘查询---》统一事件源
7.nginx
8.持久层框架
9.隧道
10.群聊--多?


error
1.合并版本的时候强行合并导致了其中的内容发生错乱，使得重新的删除原来内容，启用备份内容进行发布
	1>分支的使用
	2>合并的使用
2.在回退的时候由于每一次的commit后的标志都是很模糊的意义导致无法确定提交时候的具体内容，每一次
应该认真的书写tag


任务：
分离头文件，各自文件拥有各自的头文件，不能再将头文件汇总在一块
	预处理过程中将头文件进行复制，将每个.cpp文件进行单独归纳，则会使得每个头文件更加的专化


1.对于nginx中的模型结构，主进程负责对各个进程进行管理，销毁恢复，平稳的过度
2.子进程负责事件的accept，然后进行任务的处理，则其中会发生惊群现象。惊群事件的产生和处理，
产生的模型属于nginx中每个进程都在对监听socket进行监听，而accept不会同时使得两个进程都对其进行
成功连接

为何用管道而不用共享内存来进行主线程和从线程之间的通信，管道文件描述符，可以对其进行监听
而共享内存不能实现该功能。



lode1.cpp
//数据库中查找，是要开辟新的线程给其还是在线程中利用文件描述符制作统一事件源

//如果在此方向发现了客户端掉线就发送消息给服务器端，服务器端用此来对数据库进行操作state

//lodebalance的线程函数执行的是什么--》从客户端来的信息
//1.获得到文件描述符，如果是监听套接字，就accept，如果是连接套接字
//--1.如果是登陆信息，加上自己的文件描述符，发送给服务器--》服务器进行存储
//--2.如果是注册信息，加上自己的文件描述符，回复注册成功
//--3.如果是聊天信息，加上自己的文件描述符<如果对方在线，返回来的时候替换成对方的fd，如果对方不在线就给此人发送提示信息>

//如何知道这个客户端去了哪一个服务器，一个客户端只能并且一直连接一台服务器
//添加表，用来记录服务器和客户端的对应关系


//两种情况，一个是客户端和lb断开联系，一个是服务器与lb断开联系，客户端与lb断开来连接，将客户端的信息清除，从epoll中删除该客户端的fd,让客户端重新连接
//lb与服务器断开连接，lb中是epoll结构，而服务器中是多线程，是一个断开连接
//多个服务器进程在运行，探测到某个服务器突然断开就要重新分配该服务器中所有连接的fd给其他服务器
		
//如何知道是服务器断开连接还是只是进程之间断开连接----心跳包

server2.cpp
//未完成函数
//服务器停止之后只保留注册者user的信息，并且将所有的states中的信息都给删除
//当从lb中受到客户端断开连接之后，将其的states信息进行修改删除

//负载均衡器的功能
//从lb接受消息，由于一台服务器只连接一个负载均衡器，所以对数据的收和发都是对同一个fd进行的
//1.当客户端请求的是注册时，mysql中增加user,回复的信息中将发来的fd添加
//2.当客户端是登陆的时候，向state表中插入数据，回复信息中增加其发来的fd
//3.当客户端是聊天的时候，查询对方是否在线，如果在线就将此包中的fd更换，将消息进行转发，
//  --如果不在线的话就将消息存储message<message，from, to>，向发送来的fd回复提醒消息


client.cpp
//1.密码加密   密钥+明文
//将密钥存放在客户机中，输入信息之后，和密钥进行加密，将加密后的字符发送给服务器，然后由服务器进行匹配

//2.长连接，短链接
//3.群聊功能
//4.突发事件的处理
//5.留言功能的实现